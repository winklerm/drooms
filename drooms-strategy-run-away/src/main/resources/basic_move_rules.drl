package org.drooms.strategy.runaway;

import org.slf4j.Logger;
import org.drooms.impl.logic.PathTracker;
import org.drooms.impl.logic.facts.Positioned;
import org.drooms.impl.logic.facts.CurrentPlayer;
import org.drooms.impl.logic.events.PlayerMoveEvent;
import java.util.ArrayList;
import java.util.List;
import org.drooms.api.Move;
import org.drooms.api.Edge;
import org.drooms.api.Node;

import org.drooms.impl.logic.events.CollectibleAdditionEvent;
import org.drooms.impl.logic.events.CollectibleRemovalEvent;
import org.drooms.impl.logic.events.CollectibleRewardEvent;
import org.drooms.api.Collectible;

global Logger logger;
global PathTracker tracker;

declare entry-point rewardEvents
    @doc("A stream of reward events generated by the game")
end

declare entry-point gameEvents
    @doc("A stream of non-reward events generated by the game")
end

declare entry-point playerEvents
    @doc("A stream of events generated by players")
end

declare CurrentPosition
    node: Node
end

declare PlayerMoveEvent
    @role (event)
end

declare CollectibleAdditionEvent
    @role (event)
end

declare CollectibleRemovalEvent
    @role (event)
end

declare CollectibleRewardEvent
    @role (event)
end

declare Target
    node: Node
    collectible: AvailableCollectible
end

declare NextStep
    node: Node
end

declare Path
    startNode: Node
    endNode: Node
    edges: List
    distance: Integer
end

declare AvailableCollectible
    @role (event)
    node : Node
    collectible : Collectible
end

query isSafe(Node $node)
    not Positioned(x == $node.x, y == $node.y)
    (
        not (Positioned(x == $node.x - 1, y == $node.y))
        or
        not (Positioned(x == $node.x + 1, y == $node.y))
        or
        not (Positioned(x == $node.x, y == $node.y - 1))
        or
        not (Positioned(x == $node.x, y == $node.y + 1))
    )
end

rule "Determine current position of a player"
salience 50
when
    CurrentPlayer($p: player)
    $added: PlayerMoveEvent(player == $p) from entry-point "playerEvents"
    not PlayerMoveEvent(player == $p, this after $added) from entry-point "playerEvents"
then
    insertLogical (
        new CurrentPosition($added.getNodes().getFirst())
    );
end

rule "Collectible appeared"
salience 50
when
    $collEvent: CollectibleAdditionEvent() from entry-point "gameEvents"
    not (
        CollectibleRemovalEvent($collEvent.getNode() == node, this after $collEvent) from entry-point "gameEvents"
        or
        CollectibleRewardEvent($collEvent.getNode() == node, this after $collEvent) from entry-point "rewardEvents"
    )
then
    insertLogical( new AvailableCollectible($collEvent.getNode(), $collEvent.getCollectible()));
end

rule "Calculate path for collectible"
salience 40
when
    CurrentPosition($startNode: node)
    AvailableCollectible($collNode: node)
then
    List<Edge> path = tracker.getPath($startNode, $collNode);
    if (!path.isEmpty()) {
        insertLogical(new Path($startNode, $collNode, path, path.size()));
    }
end

rule "Determine closest collectible target"
salience 30
when
    not Target()
    CurrentPosition($startNode: node)
    $path: Path($startNode == startNode, $colNode: endNode, $closestDist: distance)
    not Path($startNode == startNode, $closestDist > distance)
    $acol: AvailableCollectible($colNode == node)
then
    insert(new Target($colNode, $acol));
end

rule "Target collectible disappeared"
salience 20
when
    $target: Target($targetNode : node, collectible != null)
    not AvailableCollectible($targetNode == node)
then
    retract($target);
end

rule "Target reached"
salience 20
when
    $target: Target($targetNode : node)
    CurrentPosition($targetNode == node)
then
    retract($target);
end

rule "Choose next step for collectible target"
salience 10
when
    $target: Target($targetNode: node, collectible != null)
    CurrentPosition($startNode: node, node != $targetNode)
    Path($startNode == startNode, $targetNode == endNode, $path: edges)
then
    if ($path.isEmpty()) {
        retract($target);
    } else {
        final Edge edge = (Edge) $path.get(0);
        final Node nextNode = edge.getNodes().getLeft() != $startNode ? 
                                edge.getNodes().getLeft() : edge.getNodes().getRight();
        insertLogical(new NextStep(nextNode));
    }
end

rule "Next non-random step must be safe"
salience 10
when
    $target: Target(collectible != null)
    $nextStep: NextStep($nextNode: node)
    not ?isSafe($nextNode;)
then
    retract($nextStep);
    retract($target);
end

rule "Determine random move - left"
when
    not Target()
    CurrentPosition($x: node.getX(), $y: node.getY())
    $nextNode : Node() from Node.getNode($x - 1, $y)
    ?isSafe($nextNode;)
then
    insertLogical(new NextStep($nextNode));
end

rule "Determine random move - right"
when
    not Target()
    CurrentPosition($x: node.getX(), $y: node.getY())
    $nextNode : Node() from Node.getNode($x + 1, $y)
    ?isSafe($nextNode;)
then
    insertLogical(new NextStep($nextNode));
end

rule "Determine random move - up"
when
    not Target()
    CurrentPosition($x: node.getX(), $y: node.getY())
    $nextNode : Node() from Node.getNode($x, $y + 1)
    ?isSafe($nextNode;)
then
    insertLogical(new NextStep($nextNode));
end

rule "Determine random move - down"
when
    not Target()
    CurrentPosition($x: node.getX(), $y: node.getY())
    $nextNode : Node() from Node.getNode($x, $y - 1)
    ?isSafe($nextNode;)
then
    insertLogical(new NextStep($nextNode));
end

rule "Determine whether next move is to the left"
when
    NextStep($nextX: node.getX(), $nextY: node.getY())
    CurrentPosition($nextX < node.getX())
then
    logger.debug("LEFT move is it.");
    insertLogical( Move.LEFT );
end

rule "Determine whether next move is to the right"
when
    NextStep($nextX: node.getX(), $nextY: node.getY())
    CurrentPosition($nextX > node.getX())
then
    logger.debug("RIGHT move is it.");
    insertLogical( Move.RIGHT );
end

rule "Determine whether next move is up"
when
    NextStep($nextX: node.getX(), $nextY: node.getY())
    CurrentPosition($nextY > node.getY())
then
    logger.debug("UP move is it.");
    insertLogical( Move.UP );
end

rule "Determine whether next move is down"
when
    NextStep($nextX: node.getX(), $nextY: node.getY())
    CurrentPosition($nextY < node.getY())
then
    logger.debug("DOWN move is it.");
    insertLogical( Move.DOWN );
end

rule "Pick move determined as the best one"
salience -10
when
    $move : Move()
then
    channels["decision"].send($move);
end
