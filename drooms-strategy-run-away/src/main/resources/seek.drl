package org.drooms.strategy.runaway;

import org.slf4j.Logger;
import org.drooms.impl.logic.facts.Positioned;
import org.drooms.impl.logic.facts.CurrentPlayer;
import org.drooms.impl.logic.events.PlayerMoveEvent;
import java.util.ArrayList;
import org.drooms.api.Move;
import org.drooms.api.Node;

import org.drooms.impl.logic.events.CollectibleAdditionEvent;
import org.drooms.impl.logic.events.CollectibleRemovalEvent;
import org.drooms.api.Collectible;

global Logger logger;

declare entry-point rewardEvents
    @doc("A stream of reward events generated by the game")
end

declare entry-point gameEvents
    @doc("A stream of non-reward events generated by the game")
end

declare entry-point playerEvents
    @doc("A stream of events generated by players")
end

declare CurrentPosition
    node: Node
end

declare PlayerMoveEvent
    @role (event)
end

rule "Determine current position of a player"
salience 50
when
    CurrentPlayer($p: player)
    $added: PlayerMoveEvent(player == $p) from entry-point "playerEvents"
    not PlayerMoveEvent(player == $p, this after $added) from entry-point "playerEvents"
then
    insertLogical (
        new CurrentPosition($added.getNodes().getFirst())
    );
end

rule "Determine whether a position to the left is available to be moved into"
no-loop
when
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == ($x - 1), y == $y)
    $moveSuggestion : MoveSuggestion(origin == "moves", move == Move.LEFT)
then
    logger.debug("LEFT move is available.");
    modify ($moveSuggestion) {
        addRating(100)
    }
end

rule "Determine whether a position to the right is available to be moved into"
no-loop
when
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == ($x + 1), y == $y)
    $moveSuggestion : MoveSuggestion(origin == "moves", move == Move.RIGHT)
then
    logger.debug("RIGHT move is available.");
    modify ($moveSuggestion) {
        addRating(100)
    }
end

rule "Determine whether a position to the top is available to be moved into"
no-loop
when
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == $x, y == ($y + 1))
    $moveSuggestion : MoveSuggestion(origin == "moves", move == Move.UP)
then
    logger.debug("UP move is available.");
    modify ($moveSuggestion) {
        addRating(100)
    }
end

rule "Determine whether a position to the bottom is available to be moved into"
no-loop
when
    CurrentPosition($x: node.getX(), $y: node.getY())
    not Positioned(x == $x, y == ($y - 1))
    $moveSuggestion : MoveSuggestion(origin == "moves", move == Move.DOWN)
then
    logger.debug("DOWN move is available.");
    modify ($moveSuggestion) {
        addRating(100)
    }
end

query getBestMoveSuggestion(MoveSuggestion $moveSuggestion)
    $moveSuggestion := MoveSuggestion()
    $totalRating : Number() from
        accumulate( MoveSuggestion($moveSuggestion.move == move, $rating : rating, rating > 0),
                    sum($rating))

    not (
        $otherMoveSuggestion : MoveSuggestion($moveSuggestion.move != move)
        and
        $totalOtherRating : Number(this > $totalRating) from
            accumulate( MoveSuggestion($otherMoveSuggestion.move == move, $otherRating : rating, rating > 0),
                    sum($otherRating))
        )
end

rule "Pick move determined as the best one"
salience -10
when
    getBestMoveSuggestion($moveSuggestion;)
then
    channels["decision"].send($moveSuggestion.getMove());
end

// when new best collectible -> set target
// when target -> get path, set next node
// when next node -> move
